
> 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档

@[TOC](文章目录)

---

# 前言
`提示：这里可以添加本文要记录的大概内容：`

Java 数值参与计算时，不同类型的数值是无法直接参与计算的，因此需要先转换成同等类型的数值才能参与计算，转换类型分成隐式转换和强制转换。

---

`提示：以下是本篇文章正文内容，下面案例可供参考`

# 一、计算机数据的存储方式—原码、反码、补码
## 1. 原码

计算机中常用的有符号整数表示方法有原码、反码和补码。这三种表示方法都是用二进制表示有符号整数的方式，但是它们存在各自的优缺点和应用场合。
首先，原码是最简单的有符号整数表示方法。正数的原码等于它的二进制表示，最高位符号位为0，负数的原码是用最高位1表示符号位，其余位表示该数的绝对值的二进制表示。原码的加减法运算和无符号整数的加减法运算相同，但是乘法和除法运算需要将原码转换为补码进行计算。原码的范围为-2^(n-1)~2^(n-1)-1，其中最高位表示符号位。原码简单易懂，但是存在加减法运算溢出和乘法除法运算的问题，同时不利于计算机硬件的设计。
## 2. 反码
反码解决了原码加减法运算溢出的问题。正数的反码等于它的二进制表示，负数的反码是将其原码中除符号位以外的其他位按位取反得到的。反码的加减法运算和原码相同，但是乘法和除法运算需要将反码转换为补码进行计算。反码的范围和原码相同。反码主要用于简单的整数运算和表示，但在实际应用中常用到更为复杂的补码表示方法。反码中存在+0和-0两种情况，即所有位都为0和所有位都为1时的情况。这是为了解决符号位和数值位的歧义问题。
## 3. 补码
补码是解决原码和反码加减法运算溢出和符号位歧义的最常用方法。正数的补码等于它的二进制表示，负数的补码是将其原码中除符号位以外的其他位按位取反得到的再加1。补码的加减法运算和无符号整数的加减法运算相同，但是乘法和除法运算需要特殊处理。补码可以表示的有符号整数范围和原码、反码相同，为-2^(n-1)到2^(n-1)-1，其中最高位表示符号位。补码解决了原码和反码的加减法运算溢出和符号位歧义的问题，并且乘法除法运算可以直接进行计算，因此成为计算机中最常用的有符号整数表示方法。补码主要用于整数运算和表示，同时在位运算和数据存储中也有广泛的应用。补码中存在+0和-0两种情况，即所有位都为0和所有位都为1时的情况。同时，补码中最小的负数没有对应的正数表示，也就没有原码和反码，因此在一些场合需要特殊处理。
# 二、隐式转换
隐式转换的特点是小范围数据可以自动转换为大范围数据，例如 byte 类型的数值10，以二进制补码形式是0000 1010，转换成比它数值范围大的 int 类型时，二进制补码形式是0000 0000 0000 0000 0000 0000 0000 1010，数据的二进制形式直接在前边补上0，这也说明为什么隐式转换可以自动将小范围数据转换成大范围数据，相当于将一个小盒子装着东西轻易地放进一个大盒子里。
以代码为例（示例）：

```java
byte a = 10;// 0000 1010
        int b = a;// 0000 0000 0000 0000 0000 0000 0000 1010 在前边补0
        System.out.println(b);//10
```
得到的结果也是10
# 三、强制转换
强制转换顾名思义就是将数据类型强制转换成我们需要的类型，转换格式是：转换类型 新变量 = （转换类型）原类型变量
例如 int 类型的数值300转换为 byte 类型，即去掉前边的位数保留最后的8位，0000 0000 0000 0000 0000 0001 0010 1100 转换成 0010 1100。但是结果发生了变化，这个数值变成了44；以数值200为例，同理数值也发生了变化，结果变成-56。
原因是强制转换过程中，将小范围数据类型无法存放的高位数据舍去了，byte 只能存8位，那8位之前的数据也就相应的舍去了。所以强制转换类型会有损坏数据的风险，尤其是小范围数据类型转换成大范围数据类型时。
```java
int c = 300;//0000 0000 0000 0000 0000 0001 0010 1100
        byte d = (byte)c;//0010 1100 去掉前边的0
        System.out.println(d);//44

        int e = 200;//0000 0000 0000 0000 0000 0000 1100 1000
        byte f = (byte)e;//1100 1000 注意这个是补码，十进制是-56
        System.out.println(f);//结果是-56
```

---

# 总结
隐式转换原理相当于小盒子装着东西放入大盒子，可以完好无损地将数据自动转换。强制转换如果是小盒子强制放入大盒子时，和隐式转换一样数据不会损坏，但如果是大盒子强制放入小盒子时，大盒子里边装的东（数据）有时也会不可避免地发生损坏。
